#!/usr/bin/env python3

import os, sys
import argparse

# use this in the txt input file to indicate multiple splits of same file, e.g.,
# 2021-08-25-12-02-18.MP4 57 69 / 92 107 / 173 186 / 209 221
MULTIDIV = '/'

class VideoTrimTool:
  def __init__(self):
    pass

  def _validate_line(self, line):
    pieces = line.split()

    if len(pieces) % 3 == 0:
      # if multiple splits
      if len(pieces) > 3 and MULTIDIV in pieces:
        return pieces
      return pieces

    if len(pieces) != 3:
      raise RuntimeError(f"could not parse line '{' '.join(pieces)}'")

    return None

  def _parse(self, ifile):
    root = os.path.dirname(os.path.abspath(ifile))

    file = open(ifile, 'r')
    lines = file.readlines()
    file.close()

    output_dir = os.path.join(root, 'trimmed')
    os.makedirs(output_dir, exist_ok=True)

    videos = []

    for line in lines:

      # ignore comments
      if not line.startswith('#'):
        pieces = self._validate_line(line)

        file = pieces[0]
        source = os.path.join(root, file)
        start = pieces[1::3]
        end = pieces[2::3]

        # if multiple splits
        if len(start) > 1:
          splits = []
          fname, fext = os.path.splitext(file)
          for i, (s, e) in enumerate(zip(start, end)):
            splits.append((f"{fname}-s{i+1}{fext}", int(s), int(e)))
        else:
          splits = [(file, int(start[0]), int(end[0]))]
        
        for f, s, e in splits:
          fullfile = os.path.join(root, f)
          video = {
            'basename': os.path.basename(fullfile),
            'target': os.path.join(output_dir, os.path.basename(fullfile)),
            'source': source,
            'start': s,
            'end': e,
            'duration': e - s
          }
          videos.append(video)

    return videos


  def create_template_file(self, ifile):
    root = os.path.dirname(os.path.abspath(ifile))

    # get all the files in the directory of interest
    files = [f for f in os.listdir(root) 
              if os.path.isfile(os.path.join(root, f))
                    and not f.startswith('.')]

    # open a file for writing
    file = open(ifile, 'w')
    file.write('# autogenerated file\n')

    for f in files:
      file.write(f"{f} 0 0\n")

    file.close()


  def trim(self, file):
    videos = self._parse(file)
    
    for v in videos:
      print()
      print(f"Processing {os.path.basename(v['basename'])} ({v['duration']} seconds)")
      
      os.system(f"ffmpeg -y -i {v['source']} -ss {v['start']} -t {v['duration']} -c copy {v['target']}")

if __name__ == '__main__':
  parser = argparse.ArgumentParser(add_help=True, description="Select a state request to test mission manager with")
  group = parser.add_mutually_exclusive_group(required=True)
  group.add_argument('-i', '--input', help="Path to video trim tool instruction text file")
  group.add_argument('-t', '--template', help="Directory in which to create a template for")

  args = parser.parse_args()

  vtt = VideoTrimTool()

  if args.input:
    vtt.trim(args.input)

  if args.template:
    file = os.path.join(args.template, 'videotrim.txt')
    vtt.create_template_file(file)

# ffmpeg -ss 65 -i 2021-08-24-21-57-50.MP4 -t 5 -c copy ~/Documents/out.mp4
# ffmpeg -ss 65 -i 2021-08-24-21-57-50.MP4 -c:v libx264 -c:a aac -strict experimental -b:a 128k ~/Documents/out.mp4